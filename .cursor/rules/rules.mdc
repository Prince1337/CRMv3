---
description: 
globs: 
alwaysApply: true
---
✅ Notwendigkeit & Einfachheit
YAGNI (You Ain’t Gonna Need It)
Implementiere nur das, was aktuell benötigt wird – keine Spekulation auf zukünftige Features.

KISS (Keep it simple, stupid)
Schreibe klaren, einfachen Code – vermeide unnötige Komplexität.

Beware of Premature Optimization
Optimiere nicht vorzeitig. Erst messen, dann gezielt verbessern.

🔁 Entwicklungsstrategien
Incremental Development
Entwickle in kleinen, funktionalen Inkrementen.

Iterative Development
Wiederhole Entwicklungszyklen mit regelmäßigem Feedback.

Design before Implementation
Klare Architektur und Designentscheidungen vor dem Coding treffen.

Design and Implementation Don’t Overlap
Trenne konzeptionelle und praktische Umsetzung konsequent.

🧪 Testing und Qualitätssicherung
Test First
Schreibe zuerst Tests, dann die Implementierung.

Automated Unit Tests
Jede Komponente muss durch Unit-Tests abgedeckt sein.

Automated Integrationtests
Komponenten müssen im Zusammenspiel automatisiert getestet werden.

Statical Code Analysis
Nutze statische Codeanalyse zur Einhaltung von Qualitätsstandards.

Error Measurement
Verfolge Fehler systematisch zur Qualitätsverbesserung.

🧱 Architekturprinzipien
Dependency Inversion Principle (DIP)
High-Level-Module sollen nicht von Low-Level-Modulen abhängen – beide hängen von Abstraktionen.

Open Closed Principle (OCP)
Software soll offen für Erweiterung, aber geschlossen für Modifikation sein.

Component Orientation
Baue Systeme aus unabhängigen, wiederverwendbaren Komponenten.

Integration Operation Segregation Principle
Integration und Operation sollten sauber getrennt sein.

🧰 Arbeitsmethoden & Prozesse
Continuous Integration (CI)
Code wird regelmäßig integriert und getestet.

Continuous Delivery (CD)
Software soll jederzeit auslieferbar sein.

Issue Tracking

Jedes Feature oder Problem wird über ein Ticketsystem dokumentiert und verfolgt.