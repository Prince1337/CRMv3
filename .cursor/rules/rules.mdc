---
description: 
globs: 
alwaysApply: true
---
âœ… Notwendigkeit & Einfachheit
YAGNI (You Ainâ€™t Gonna Need It)
Implementiere nur das, was aktuell benÃ¶tigt wird â€“ keine Spekulation auf zukÃ¼nftige Features.

KISS (Keep it simple, stupid)
Schreibe klaren, einfachen Code â€“ vermeide unnÃ¶tige KomplexitÃ¤t.

Beware of Premature Optimization
Optimiere nicht vorzeitig. Erst messen, dann gezielt verbessern.

ğŸ” Entwicklungsstrategien
Incremental Development
Entwickle in kleinen, funktionalen Inkrementen.

Iterative Development
Wiederhole Entwicklungszyklen mit regelmÃ¤ÃŸigem Feedback.

Design before Implementation
Klare Architektur und Designentscheidungen vor dem Coding treffen.

Design and Implementation Donâ€™t Overlap
Trenne konzeptionelle und praktische Umsetzung konsequent.

ğŸ§ª Testing und QualitÃ¤tssicherung
Test First
Schreibe zuerst Tests, dann die Implementierung.

Automated Unit Tests
Jede Komponente muss durch Unit-Tests abgedeckt sein.

Automated Integrationtests
Komponenten mÃ¼ssen im Zusammenspiel automatisiert getestet werden.

Statical Code Analysis
Nutze statische Codeanalyse zur Einhaltung von QualitÃ¤tsstandards.

Error Measurement
Verfolge Fehler systematisch zur QualitÃ¤tsverbesserung.

ğŸ§± Architekturprinzipien
Dependency Inversion Principle (DIP)
High-Level-Module sollen nicht von Low-Level-Modulen abhÃ¤ngen â€“ beide hÃ¤ngen von Abstraktionen.

Open Closed Principle (OCP)
Software soll offen fÃ¼r Erweiterung, aber geschlossen fÃ¼r Modifikation sein.

Component Orientation
Baue Systeme aus unabhÃ¤ngigen, wiederverwendbaren Komponenten.

Integration Operation Segregation Principle
Integration und Operation sollten sauber getrennt sein.

ğŸ§° Arbeitsmethoden & Prozesse
Continuous Integration (CI)
Code wird regelmÃ¤ÃŸig integriert und getestet.

Continuous Delivery (CD)
Software soll jederzeit auslieferbar sein.

Issue Tracking

Jedes Feature oder Problem wird Ã¼ber ein Ticketsystem dokumentiert und verfolgt.